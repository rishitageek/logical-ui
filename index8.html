<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Responsive Sudoku / Crossword Grid</title>
        <style>
            :root {
                --gap: 6px;
                --cell-size: clamp(34px, 5.2vmin, 64px); /* responsive cell */
                --board-padding: 12px;
                --accent: #2563eb;
                --muted: #cbd5e1;
                --bg: #0f172a;
                --card: #ffffff;
            }

            /* Page layout */
            html,
            body {
                height: 100%;
                margin: 0;
                font-family: Inter, system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial;
            }
            body {
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 20px;
                background: linear-gradient(180deg, #eef2ff 0%, #fff 100%);
            }

            .container {
                width: 100%;
                max-width: 1200px;
                display: grid;
                grid-template-columns: 360px 1fr;
                gap: 24px;
                align-items: start;
            }
            @media (max-width: 880px) {
                .container {
                    grid-template-columns: 1fr;
                }
            }

            .panel {
                background: var(--card);
                border-radius: 12px;
                padding: 18px;
                box-shadow: 0 6px 20px rgba(16, 24, 40, 0.06);
            }
            .controls {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .controls .row {
                display: flex;
                gap: 8px;
                align-items: center;
            }
            label {
                font-size: 14px;
                color: #0f172a;
            }
            select,
            input[type="number"] {
                padding: 8px;
                border: 1px solid var(--muted);
                border-radius: 8px;
            }
            button {
                padding: 8px 12px;
                border-radius: 8px;
                border: 0;
                background: var(--accent);
                color: #fff;
                cursor: pointer;
            }
            .muted {
                font-size: 13px;
                color: #475569;
            }

            /* Board wrapper scales with width */
            .board-wrap {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }
            .board-top {
                display: flex;
                justify-content: space-between;
                align-items: center;
            }

            /* Grid container: uses CSS variable --size to set columns */
            .grid {
                --size: 9; /* fallback */
                display: grid;
                gap: var(--gap);
                padding: var(--board-padding);
                background: linear-gradient(180deg, #f8fafc, #fff);
                border-radius: 12px;
                box-shadow: inset 0 1px 0 rgba(0, 0, 0, 0.02);
                width: 100%;
                box-sizing: border-box;
            }

            /* each cell is a square using aspect-ratio */
            .cell {
                width: var(--cell-size);
                aspect-ratio: 1/1;
                display: flex;
                align-items: center;
                justify-content: center;
                border-radius: 8px;
                background: #fbfdff; /* light */
                position: relative;
                user-select: none;
                overflow: hidden;
            }

            /* Input inside cell */
            .cell input {
                width: 100%;
                height: 100%;
                border: 0;
                background: transparent;
                font-size: clamp(14px, 3.5vmin, 28px);
                text-align: center;
                outline: none;
                color: #0b1220;
                font-weight: 600;
            }

            /* black cell for crossword */
            .cell.black {
                background: #0b1220;
                border-radius: 6px;
            }

            /* thick borders for sudoku 3x3 boxes */
            .cell.box-border-top {
                box-shadow: inset 0 6px 0 0 rgba(0, 0, 0, 0.04);
            }

            /* highlight focus & selection */
            .cell.focus {
                outline: 3px solid rgba(37, 99, 235, 0.12);
            }
            .cell.highlight {
                background: linear-gradient(90deg, rgba(37, 99, 235, 0.08), rgba(99, 102, 241, 0.03));
            }
            .cell.conflict {
                background: linear-gradient(90deg, rgba(239, 68, 68, 0.12), rgba(248, 113, 113, 0.02));
            }

            /* grid auto columns/rows based on --size variable */
            .grid[data-size] {
                grid-template-columns: repeat(var(--size), minmax(0, 1fr));
                justify-content: center;
            }

            /* responsive: allow grid to shrink and cells to scale down */
            @media (max-width: 480px) {
                :root {
                    --cell-size: clamp(28px, 7.5vmin, 44px);
                }
                .container {
                    padding: 6px;
                }
            }

            /* footer small help */
            .help {
                font-size: 13px;
                color: #475569;
            }

            /* small utilities */
            .controls .btn-row {
                display: flex;
                gap: 8px;
            }
            .hint {
                font-size: 12px;
                color: #64748b;
            }

            /* make board center on small screens */
            .board-area {
                display: flex;
                align-items: center;
                justify-content: center;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <aside class="panel controls">
                <div class="row">
                    <label for="mode">Mode</label>
                    <select id="mode" aria-label="Mode select">
                        <option value="sudoku">Sudoku (9×9)</option>
                        <option value="crossword">Crossword (editable size)</option>
                    </select>
                </div>

                <div class="row">
                    <label for="size">Grid size</label>
                    <input id="size" type="number" min="5" max="21" value="9" aria-label="Grid size" />
                </div>

                <div class="row btn-row">
                    <button id="generate">Generate Grid</button>
                    <button id="clear" style="background: #ef4444">Clear</button>
                </div>

                <div class="muted help">
                    Tips:
                    <ul style="margin: 6px 0 0 18px; padding: 0">
                        <li>Sudoku: only digits 1-9 allowed.</li>
                        <li>Crossword: click a cell to toggle black/white.</li>
                        <li>Use arrows to move between cells.</li>
                    </ul>
                </div>

                <div style="margin-top: 12px">
                    <div class="muted">Quick actions</div>
                    <div style="display: flex; gap: 8px; margin-top: 8px">
                        <button id="fill-sample">Fill sample (sudoku)</button>
                        <button id="toggle-gridlines">Toggle Grid Lines</button>
                    </div>
                </div>
            </aside>

            <main class="panel board-wrap">
                <div class="board-top">
                    <h3 style="margin: 0">Grid Preview</h3>
                    <div class="muted">Responsive, keyboard-friendly grid</div>
                </div>

                <div class="board-area">
                    <div id="grid" class="grid" data-size="9" style="--size: 9"></div>
                </div>

                <div style="margin-top: 12px; display: flex; justify-content: space-between; align-items: center">
                    <div class="help">Click a cell to edit. For crossword mode, click again to toggle black cell.</div>
                    <div class="muted">Made for demonstration • Resize your browser to see responsiveness</div>
                </div>
            </main>
        </div>

        <script>
            // Responsive Sudoku / Crossword Grid Generator
            (function () {
                const modeEl = document.getElementById("mode");
                const sizeEl = document.getElementById("size");
                const gridEl = document.getElementById("grid");
                const generateBtn = document.getElementById("generate");
                const clearBtn = document.getElementById("clear");
                const fillSample = document.getElementById("fill-sample");
                const toggleGridlines = document.getElementById("toggle-gridlines");

                let state = {
                    mode: "sudoku",
                    size: 9,
                    cells: [], // {value, black}
                };

                function makeGrid(size, mode) {
                    state.size = size;
                    state.mode = mode;
                    state.cells = Array.from({ length: size * size }).map(() => ({ value: "", black: false }));
                    render();
                }

                function render() {
                    const n = state.size;
                    gridEl.setAttribute("data-size", n);
                    gridEl.style.setProperty("--size", n);
                    gridEl.innerHTML = "";

                    // adjust layout width to contain grid but allow wrapping on small screens
                    // create cells
                    for (let r = 0; r < n; r++) {
                        for (let c = 0; c < n; c++) {
                            const idx = r * n + c;
                            const cellData = state.cells[idx];
                            const cell = document.createElement("div");
                            cell.className = "cell";
                            cell.dataset.index = idx;
                            cell.tabIndex = 0;

                            // add thicker borders for 3x3 boxes in sudoku mode (only if size==9)
                            if (state.mode === "sudoku" && n === 9) {
                                // set custom border radius visually by shadow – simpler for demo
                                if (r % 3 === 0) cell.classList.add("box-border-top");
                            }

                            if (state.mode === "crossword") {
                                if (cellData.black) cell.classList.add("black");
                                // toggle black on click
                                cell.addEventListener("click", (e) => {
                                    // if clicked directly on input, don't toggle
                                    if (e.target.tagName === "INPUT") return;
                                    cellData.black = !cellData.black;
                                    cell.classList.toggle("black", cellData.black);
                                    // clear value when black
                                    if (cellData.black) {
                                        cellData.value = "";
                                        const inp = cell.querySelector("input");
                                        if (inp) inp.value = "";
                                    }
                                });
                            }

                            const input = document.createElement("input");
                            input.inputMode = state.mode === "sudoku" ? "numeric" : "text";
                            input.maxLength = state.mode === "sudoku" ? 1 : 1; // crossword single char cell
                            input.value = cellData.value;
                            input.disabled = cellData.black;

                            // keyboard navigation
                            input.addEventListener("keydown", (ev) => {
                                const key = ev.key;
                                const idx = Number(cell.dataset.index);
                                if (key === "ArrowLeft") {
                                    ev.preventDefault();
                                    focusCell(idx - 1);
                                }
                                if (key === "ArrowRight") {
                                    ev.preventDefault();
                                    focusCell(idx + 1);
                                }
                                if (key === "ArrowUp") {
                                    ev.preventDefault();
                                    focusCell(idx - state.size);
                                }
                                if (key === "ArrowDown") {
                                    ev.preventDefault();
                                    focusCell(idx + state.size);
                                }
                                if (key === "Backspace" || key === "Delete") {
                                    cellData.value = "";
                                    setTimeout(() => {
                                        input.value = "";
                                        validateConflicts();
                                    }, 0);
                                }
                            });

                            input.addEventListener("input", (ev) => {
                                let v = ev.target.value;
                                if (state.mode === "sudoku") {
                                    // allow only digits 1-9
                                    v = v.replace(/[^1-9]/g, "").slice(0, 1);
                                    ev.target.value = v;
                                    cellData.value = v;
                                    validateConflicts();
                                    // auto move right if filled
                                    if (v) {
                                        focusCell(Number(cell.dataset.index) + 1);
                                    }
                                } else {
                                    v = v
                                        .replace(/[^A-Za-z0-9]/g, "")
                                        .slice(0, 1)
                                        .toUpperCase();
                                    ev.target.value = v;
                                    cellData.value = v;
                                    // move right
                                    if (v) {
                                        focusCell(Number(cell.dataset.index) + 1);
                                    }
                                }
                            });

                            input.addEventListener("focus", () => {
                                // highlight row/col/box
                                highlightRelated(Number(cell.dataset.index));
                            });

                            input.addEventListener("blur", () => {
                                removeHighlights();
                            });

                            cell.appendChild(input);
                            gridEl.appendChild(cell);
                        }
                    }
                }

                function focusCell(idx) {
                    if (idx < 0 || idx >= state.size * state.size) return;
                    const target = gridEl.querySelector(`.cell[data-index='${idx}'] input`);
                    if (target && !target.disabled) {
                        target.focus();
                        target.select();
                    }
                }

                function highlightRelated(idx) {
                    const n = state.size;
                    const r = Math.floor(idx / n);
                    const c = idx % n;
                    removeHighlights();
                    for (let i = 0; i < n; i++) {
                        const rowCell = gridEl.querySelector(`.cell[data-index='${r * n + i}']`);
                        const colCell = gridEl.querySelector(`.cell[data-index='${i * n + c}']`);
                        if (rowCell) rowCell.classList.add("highlight");
                        if (colCell) colCell.classList.add("highlight");
                    }
                    if (state.mode === "sudoku" && n === 9) {
                        const br = Math.floor(r / 3) * 3;
                        const bc = Math.floor(c / 3) * 3;
                        for (let rr = br; rr < br + 3; rr++) {
                            for (let cc = bc; cc < bc + 3; cc++) {
                                const bcell = gridEl.querySelector(`.cell[data-index='${rr * n + cc}']`);
                                if (bcell) bcell.classList.add("highlight");
                            }
                        }
                    }
                }
                function removeHighlights() {
                    gridEl.querySelectorAll(".cell.highlight").forEach((n) => n.classList.remove("highlight"));
                }

                function validateConflicts() {
                    // clear previous conflicts
                    gridEl.querySelectorAll(".cell.conflict").forEach((n) => n.classList.remove("conflict"));
                    if (state.mode !== "sudoku") return;
                    const n = state.size;
                    if (n !== 9) return; // only validate 9x9 for demo

                    const vals = state.cells.map((c) => c.value || "");
                    // rows
                    for (let r = 0; r < n; r++) {
                        const seen = {};
                        for (let c = 0; c < n; c++) {
                            const v = vals[r * n + c];
                            if (!v) continue;
                            if (seen[v]) {
                                // mark conflict for both
                                gridEl.querySelector(`.cell[data-index='${r * n + c}']`).classList.add("conflict");
                                gridEl
                                    .querySelector(`.cell[data-index='${r * n + seen[v] - 1}']`)
                                    .classList.add("conflict");
                            } else seen[v] = c + 1; // store column +1
                        }
                    }
                    // cols
                    for (let c = 0; c < n; c++) {
                        const seen = {};
                        for (let r = 0; r < n; r++) {
                            const v = vals[r * n + c];
                            if (!v) continue;
                            if (seen[v]) {
                                gridEl.querySelector(`.cell[data-index='${r * n + c}']`).classList.add("conflict");
                                gridEl.querySelector(`.cell[data-index='${seen[v] - 1}*${n} + ${c}']`); // noop to keep pattern
                                // also mark previous occurrence
                                gridEl
                                    .querySelector(`.cell[data-index='${(seen[v] - 1) * n + c}']`)
                                    .classList.add("conflict");
                            } else seen[v] = r + 1;
                        }
                    }
                    // boxes
                    for (let br = 0; br < 3; br++) {
                        for (let bc = 0; bc < 3; bc++) {
                            const seen = {};
                            for (let r = 0; r < 3; r++) {
                                for (let c = 0; c < 3; c++) {
                                    const R = br * 3 + r;
                                    const C = bc * 3 + c;
                                    const v = vals[R * n + C];
                                    if (!v) continue;
                                    if (seen[v]) {
                                        gridEl
                                            .querySelector(`.cell[data-index='${R * n + C}']`)
                                            .classList.add("conflict");
                                        const prev = seen[v] - 1;
                                        gridEl.querySelector(`.cell[data-index='${prev}']`).classList.add("conflict");
                                    } else seen[v] = R * n + C + 1; // store index+1
                                }
                            }
                        }
                    }
                }

                // wire controls
                generateBtn.addEventListener("click", () => {
                    const mode = modeEl.value;
                    let size = parseInt(sizeEl.value, 10) || 9;
                    if (mode === "sudoku") size = 9; // sudoku fixed size for demo
                    size = Math.max(5, Math.min(21, size));
                    sizeEl.value = size;
                    makeGrid(size, mode);
                });

                clearBtn.addEventListener("click", () => {
                    state.cells.forEach((c) => {
                        c.value = "";
                        c.black = false;
                    });
                    render();
                });

                fillSample.addEventListener("click", () => {
                    if (state.mode !== "sudoku" || state.size !== 9) return;
                    // sample starting numbers (easy)
                    const sample = [
                        5,
                        3,
                        "",
                        "",
                        "",
                        7,
                        "",
                        "",
                        "",
                        6,
                        "",
                        "",
                        "1",
                        9,
                        5,
                        "",
                        "",
                        "",
                        "",
                        9,
                        8,
                        "",
                        "",
                        "",
                        "",
                        "6",
                        "",
                        8,
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        6,
                        "",
                        4,
                        "",
                        "",
                        "8",
                        "",
                        "3",
                        "",
                        "",
                        1,
                        7,
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        2,
                        "",
                        6,
                        "",
                        "",
                        "",
                        "",
                        "2",
                        8,
                        "",
                        "",
                        "",
                        "",
                        "4",
                        1,
                        9,
                        "",
                        "",
                        "5",
                        "",
                        "",
                        "",
                        "",
                        8,
                        "",
                        "",
                        7,
                        9,
                    ];
                    state.cells = state.cells.map((c, i) => ({ value: sample[i] || "", black: false }));
                    render();
                    // populate inputs
                    gridEl.querySelectorAll(".cell input").forEach((inp, i) => {
                        inp.value = state.cells[i].value || "";
                    });
                    validateConflicts();
                });

                toggleGridlines.addEventListener("click", () => {
                    gridEl.classList.toggle("no-gap");
                    if (gridEl.classList.contains("no-gap")) {
                        gridEl.style.setProperty("gap", "0px");
                        document.querySelectorAll(".cell").forEach((c) => (c.style.borderRadius = "0"));
                    } else {
                        gridEl.style.setProperty("gap", "var(--gap)");
                        document.querySelectorAll(".cell").forEach((c) => (c.style.borderRadius = "8px"));
                    }
                });

                // on load: initial grid
                makeGrid(9, "sudoku");

                // ensure state.cells keeps updated when user types - we already write to state on input; but initial render should wire values
                // Observe inputs to update state on blur (in case value changed programmatically)
                gridEl.addEventListener("input", (e) => {
                    // find index for changed input
                    const input = e.target;
                    const idx = Number(input.closest(".cell").dataset.index);
                    state.cells[idx].value = input.value;
                });

                // handle window resize: reduce --cell-size if grid too wide
                function fitCells() {
                    // let CSS handle with clamp(). Additional custom sizing can be added here if needed.
                }
                window.addEventListener("resize", fitCells);
            })();
        </script>
    </body>
</html>
